"""
Main Entry Point

gRPC server for video translation service.
Follows best-practices/00-ARCHITECTURE.md deployment patterns.
"""

import asyncio
import logging
import sys
from pathlib import Path

import grpc
from .app_logging import get_logger

logger = get_logger("main")

try:
    from grpc_reflection.v1alpha import reflection
    REFLECTION_AVAILABLE = True
except ImportError:
    REFLECTION_AVAILABLE = False
    logger.warning("gRPC reflection not available")

# Proto imports - will be generated by entrypoint script
try:
    from .proto import translation_pb2, translation_pb2_grpc
except ImportError:
    # Fallback for development
    import sys
    from pathlib import Path
    proto_path = Path(__file__).parent / "proto"
    sys.path.insert(0, str(proto_path))
    import translation_pb2
    import translation_pb2_grpc
from .services.grpc_service import TranslationServicer
from .config import get_config
from .app_logging import get_logger
from .core import get_resource_manager, get_cleanup_manager
from .observability import setup_observability

logger = get_logger("main")


async def serve():
    """Start gRPC server."""
    config = get_config()
    
    # Setup observability
    if config.settings.enable_tracing:
        setup_observability(config)
    
    # Start resource monitoring
    resource_manager = get_resource_manager()
    await resource_manager.start_monitoring()
    
    # Start periodic cleanup
    cleanup_manager = get_cleanup_manager()
    await cleanup_manager.start_periodic_cleanup()
    
    # Create gRPC server with keepalive options
    # Configure server options for keepalive to prevent RESOURCE_EXHAUSTED errors
    # For long-running video translations, we need very high connection age limits
    
    # Time constants (in milliseconds)
    SECONDS_MS = 1000
    MINUTES_MS = 60 * SECONDS_MS
    HOURS_MS = 60 * MINUTES_MS
    
    server_options = [
        ('grpc.keepalive_time_ms', 30 * SECONDS_MS),  # 30 seconds - same as client
        ('grpc.keepalive_timeout_ms', 10 * SECONDS_MS),  # 10 seconds timeout
        ('grpc.keepalive_permit_without_calls', True),  # Allow pings without active calls
        ('grpc.http2.max_pings_without_data', 0),  # Allow unlimited pings
        ('grpc.http2.min_time_between_pings_ms', 10 * SECONDS_MS),  # Minimum 10s between pings
        ('grpc.http2.min_ping_interval_without_data_ms', 30 * SECONDS_MS),  # 30s minimum interval
        ('grpc.max_connection_idle_ms', 1 * HOURS_MS),  # 1 hour (for idle connections)
        ('grpc.max_connection_age_ms', 24 * HOURS_MS),  # 24 hours (for long video translations)
        ('grpc.max_connection_age_grace_ms', 1 * MINUTES_MS),  # 1 minute grace period
    ]
    
    server = grpc.aio.server(options=server_options)
    
    # Add servicer
    translation_pb2_grpc.add_TranslationServiceServicer_to_server(
        TranslationServicer(), server
    )
    
    # Enable reflection for debugging (if available)
    if REFLECTION_AVAILABLE:
        try:
            SERVICE_NAMES = (
                translation_pb2.DESCRIPTOR.services_by_name['TranslationService'].full_name,
                reflection.SERVICE_NAME,
            )
            reflection.enable_server_reflection(SERVICE_NAMES, server)
        except Exception as e:
            logger.warning("Failed to enable gRPC reflection", extra_data={"error": str(e)})
    
    # Listen on port
    listen_addr = f"[::]:{config.settings.grpc_port}"
    server.add_insecure_port(listen_addr)
    
    logger.info(
        f"Starting gRPC server on {listen_addr}",
        extra_data={
            "port": config.settings.grpc_port,
            "environment": config.settings.environment,
        },
    )
    
    # Start server
    await server.start()
    
    logger.info("gRPC server started successfully")
    
    # Wait for termination
    try:
        await server.wait_for_termination()
    except KeyboardInterrupt:
        logger.info("Shutting down server...")
        await server.stop(5)
        await resource_manager.stop_monitoring()
        logger.info("Server shut down complete")


def main():
    """Main entry point."""
    # Configure logging
    logging.basicConfig(
        level=getattr(logging, get_config().settings.log_level.upper()),
        format="%(message)s",
    )
    
    try:
        asyncio.run(serve())
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
        sys.exit(0)
    except Exception as e:
        logger.error("Fatal error", exc_info=True, extra_data={"error": str(e)})
        sys.exit(1)


if __name__ == "__main__":
    main()

